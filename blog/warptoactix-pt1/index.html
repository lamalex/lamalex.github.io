<!DOCTYPE html>
<html>
    

<head>
    <title>Alex Launi, UNO enthusiast</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta property="og:site_name" content="https://launi.me" |safe />
    <meta property="og:title" content="Home - https://launi.me" |safe />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https:&#x2F;&#x2F;launi.me&#x2F;blog&#x2F;warptoactix-pt1&#x2F;" />
    <meta name="twitter:creator" content="@rhonda_jeremy" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" type="text/css" href="https://launi.me/style.css" />
    
    
</head>

<body class="party" style>
    <header role="banner" class="Site-head pad-top-500">
        <div class="wrapper wrapper-lg">
            <div class="Site-head__inner box-flex space-between align-center">
                <nav class="nav">
                    <ul class="nav__list box-flex align-center md:space-before">
                        <li class="nav__item">
                            <a href="https://launi.me" aria-current="page" class="nav__item-hover"
                                data-id="blog">
                                <span class="nav__item-hover-inner" data-hover="blog">
                                    home
                                </span>
                            </a>
                        </li>
                        <li class="nav__item">
                            <a href="https://launi.me/blog" aria-current="page" class="nav__item-hover"
                                data-id="blog">
                                <span class="nav__item-hover-inner" data-hover="blog">
                                    blog
                                </span>
                            </a>
                        </li>
                        <li class="nav__item">
                            <a href="https://launi.me/cv" aria-current="page" class="nav__item-hover"
                                data-id="cv">
                                <span class="nav__item-hover-inner" data-hover="blog">
                                    cv
                                </span>
                            </a>
                        </li>
                    </ul>
                </nav>

                <div class="theme-switch-wrapper">
                    ðŸŽ‰
                    <label class="theme-switch" for="checkbox">
                        <input type="checkbox" id="checkbox" />
                        <div class="slider round"></div>
                    </label>
                    ðŸ’€
                </div>

            </div>
        </div>
    </header>
    <main id="main-content" tabindex="-1" class="content">
        <div class="pad-before-xlg">
            <div class="wrapper wrapper-sm pad-before">

                <header class="Intro pad-around">
                    <div class="Intro__inner inner-wrapper">
                        <div class="Intro__copy">
                            
<h1 class="Intro__heading h3">Refactoring Rust: `let service = Actix::from&lt;Warp&gt;()` pt. 1</h1>
    <div class="Intro__byline h6">
        <h3 id="this-post-is-a-part-of-a-series">This post is a part of a series</h3>
<p>For a variety of reasons I am refactoring a web server that I built using Warp, to an equivalent service built on Actix.
I bought <a href="https://www.zero2prod.com">Luca Palmieri's book <code>Zero To Production In Rust</code></a> a long time ago, and wanted to integrate some of it into
this web service, but never got around to it. Now I have some spare time, and some practical incentive. Rather than just copying the book and implementing
the mailing list service that he builds, I thought I would walk through it and incorporate the concepts into this Rust service, hopefully also fixing the bug that we are experiencing.
Nothing in here should be interperted to be &quot;the best way&quot;, but is an experimental work in progress. Please feel free to <a href="mailto:dev@launi.me">reach out</a> if there is something you think I could be doing better!</p>
<h3 id="part-1-our-first-endpoint-a-basic-health-check">Part 1: Our First Endpoint: A Basic Health Check</h3>
<p><em>This post is being written post-facto. Some of the code snippets may not be 100% correct. In the future I will try to blog contemporanesously with the work.</em></p>
<p>In Luca's book the first semi-meaningful route we define is a health check app. Our existing service has a similar endpoint at <code>/v1/heartbeat</code> which returns a monotonically increasing u64 value.
The hard part we will face is abstracting over the webserver implementation we are using so that <code>Actix</code> or <code>Warp</code> can be switched off and on at compile time.</p>
<p>First we need to create an instance of a webserver. Both Actix and Warp use Rust's async infrastructure, and can use Tokio as the async runtime. Luca provides this sample code to create a server in Actix</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
HttpServer::new(|| { App::new()
.route(&quot;&#x2F;&quot;, web::get().to(greet)) .route(&quot;&#x2F;{name}&quot;, web::get().to(greet))
    })
    .bind(&quot;127.0.0.1:8000&quot;)?
    .run()
    .await
}
</code></pre>
<p>in our current Warp based implementation we do:</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">mod webserver {
    use super::filters;

    use std::net::SocketAddrV4;
    use warp::Filter;

    use liftright_data_server::LrdsError;

    #[tokio::main]
    pub async fn run(port: u32) -&gt; Result&lt;(), LrdsError&gt; {
        let db = liftright_data_server::establish_db_connection().await?;

        let api = filters::rest_api(db).with(warp::log(&quot;liftright_data_server&quot;));

        let addr: SocketAddrV4 = format!(&quot;0.0.0.0:{}&quot;, port)
            .parse()
            .expect(&quot;Could not create IP.&quot;);

        warp::serve(api).run(addr).await;
        Ok(())
    }
}
</code></pre>
<p>It looks like we have something like a common denominator here. Both servers have a <code>run</code> method that returns a future, and return a <code>Result</code> type. We can update our main to have 2 near equal versions depending on the value of our <code>actix</code> feature flag.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">
&#x2F;&#x2F; NOTE: ***
&#x2F;&#x2F;  I&#x27;m still thinking about a way to only have the runtime proc macro be feature flag dependent
&#x2F;&#x2F;  so that I can combine the implementations. I think a small macro should work, but it&#x27;s
&#x2F;&#x2F;  a low priority enhancement.
#[cfg(feature = &quot;actix&quot;)]
#[actix_web::main]
async fn run(port: u64) -&gt; Result&lt;(), LrdsError&gt; {
    webserver::run(port)?.await.unwrap();
    Ok(())
}

#[cfg(not(feature = &quot;actix&quot;))]
#[tokio::main]
async fn run(port: u64) -&gt; Result&lt;(), LrdsError&gt; {
    webserver::run(port)?.await.unwrap();
    Ok(())
}

pub mod webserver {
    ...

    pub async fn run(port: u64) -&gt; Result&lt;(), LrdsError&gt; {
        webserver_impl::run(port)?.await
    }

    #[cfg(feature = &quot;actix&quot;)]
    mod webserver_impl {
        ...

        pub fn run(port: u64) -&gt; std::io::Result&lt;()&gt; {
            let server = HttpServer::new(|| {
                App::new()
                    .route(&quot;&#x2F;&quot;, web::get().to(greet))
                    .route(&quot;&#x2F;{name}&quot;, web::get().to(greet))
                    .route(&quot;v1&#x2F;heartbeat&quot;, web::get().to(health_check))
            })
            .bind(format!(&quot;127.0.0.0:{}&quot;, port))?
            .run()
            .await;

            Ok(())
        }   
    }

    #[cfg(not(feature = &quot;actix&quot;))]
    mod webserver_impl {
        ...

        pub async fn run(port: u64) -&gt; Result&lt;(), LrdsError&gt; {
            let db = crate::establish_db_connection().await?;
            let api = filters::rest_api(db).with(warp::log(&quot;liftright_data_server&quot;));

            let addr: SocketAddrV4 = format!(&quot;0.0.0.0:{}&quot;, port)
                .parse()
                .expect(&quot;Could not create IP.&quot;);

            warp::serve(api).run(addr).await;
            Ok(())
        }
    }
</code></pre>
<p>Hey cool! This works! Actix can now be started with the flip of a <code>--features actix</code> switch on <code>cargo run</code>. Adding the health check endpoint is trivial (and would just be plaigarized from the book).
To make the implementations match I slightly changed the <code>health_check</code> body to return a timestamp, but the first hurdle has been overcome. We can switch webservers! Truly, at this point there's not much benefit. Almost all of the code is duplicated, but we've basically just touched the framework pieces and none of our application logic. Hopefully we'll be able to share more of that down the road. For now at least step 1 of the experiment was successful.</p>
<p>The next post will cover setting up integration testing. This post will also be written post-facto, but setting up the integration testing was the impetus for blogging about this.</p>

    </div> 

                        </div>
                    </div>
                    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" role="decorative"
                        aria-hidden="true" viewBox="0 0 134 55.5" overflow="visible" class="Intro__svg">
                        <defs>
                            <pattern x="-257.8" y="0" width="5" height="5" patternUnits="userSpaceOnUse"
                                id="dot-pattern" viewBox="0 -8 8 8" overflow="visible">
                                <rect y="-8" width="8" height="8" fill="none"></rect>
                                <ellipse cx="4" cy="-4" rx="0.05" ry="1" fill="var(--color-dark)"
                                    stroke="var(--color-dark)" stroke-miterlimit="10" />
                            </pattern>
                        </defs>
                        <pattern id="SVGID_1_" xlink:href="#dot-pattern" patternTransform="translate(-1.3637 4.2113)" />
                        <rect width="133.9" height="100" fill="url(#SVGID_1_)" />
                    </svg>
                    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" role="decorative"
                        aria-hidden="true" viewBox="0 0 134 55.5" overflow="visible" class="Intro__psvg">
                        <path d="m0,0 q25,-50 100,100 L-25,100" />
                        <ellipse cx="15" cy="17" rx="12" ry="20" fill="var(--color-death-face)"
                            transform="rotate(-16)" />
                    </svg>
                </header>

                <div class="pad-around-sm flare">
                    
                </div>
            </div>
        </div>
    </main>
    <script defer="defer" src="https://launi.me/scripts/main.js"></script>
    
</body>
                    
</html>
